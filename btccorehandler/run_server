#!/usr/bin/env python3

#############################################################################
# Copyright [2023] [R0BM01@pm.me]                                           #
#                                                                           #
# Licensed under the Apache License, Version 2.0 (the "License");           #
# you may not use this file except in compliance with the License.          #
# You may obtain a copy of the License at                                   #
#                                                                           #
# http://www.apache.org/licenses/LICENSE-2.0                                #
#                                                                           #
# Unless required by applicable law or agreed to in writing, software       #
# distributed under the License is distributed on an "AS IS" BASIS,         #
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  #
# See the License for the specific language governing permissions and       #
# limitations under the License.                                            #
#############################################################################

import time, sys
import lib.settings
import lib.logger
import server.storage
import server.server
import server.machine


def certificate_choice(storage):   
    c = input("Type \n'I' to import \n'G' to generate \n'Q' to quit \n>> ").upper()
    if c == 'I': storage.import_certificate(input("Certificate path >> "))
    elif c == 'G': storage.generate_certificate()
    # return storage.check_certificate()


def main():
    storage = server.storage.Storage()
    storage.init_base()

    logger = lib.logger(storage.dir_tree['debug'], verbose = True)
    logger.add("server: version running", lib.settings.VERSION)

    ## checks if certificate is available
    if not storage.check_certificate():
        logger.add("Certificate must be generated or imported")
        certificate_choice(storage)
    logger.add("storage: certificate is available", storage.verify_certificate())

    ## checks directories and files
    logger.add("storage: checking directory tree integrity")
    for directory in storage.dir_tree:
        check = storage.check_exists(storage.dir_tree[directory])
        logger.add(f"storage: exists [{storage.dir_tree[directory]}]", check)
        if not check: 
            storage.init_dir(storage.dir_tree[directory])
            logger.add(f"storage: dir [{storage.dir_tree[directory]}] created")
    
    for file in storage.file_tree:
        check = storage.check_exists(storage.file_tree[file])
        logger.add(f"storage: exists [{storage.file_tree[file]}]", check)
        if not check:
            storage.init_file(storage.file_tree[file])
            logger.add(f"storage: file [{storage.file_tree[file]}] created")
    
    
    
    ## init Server instance
    SERVER = server.server.Server(logger, storage)
    logger.add("server: init time", SERVER.initTime)
    logger.add("server: network ip address", SERVER.NETWORK.settings.host)
    logger.add("server: network open port", SERVER.NETWORK.settings.port)
    logger.add("server: internet is reachable", bool(SERVER.internetIsOn) )
    logger.add("server: bitcoin daemon is running", bool(SERVER.bitcoindRunning) )
    
    ## init Server RPC local controller
    SERVER.localControllerThread.start()

    ## loads known geolocation data from storage
    SERVER.CACHE.geolocation_index = storage.geolocation_load_db_index()
    SERVER.CACHE.geolocation_write = storage.geolocation_write_entry
    SERVER.CACHE.geolocation_read = storage.geolocation_load_entry
    logger.add("geolocation: data loaded from storage", bool(SERVER.CACHE.geolocation_index))

    if SERVER.bitcoindRunning:
        logger.add("server: updating bitcoin cached data")
        SERVER.CACHE.get_bitcoin_info()
        #SERVER.updateCacheData()

        logger.add("bitcoin: client", SERVER.BITCOIN_DATA.networkInfo['subversion'])
        logger.add("bitcoin: uptime", SERVER.BITCOIN_DATA.uptime['uptime'])
        logger.add("bitcoin: chain", SERVER.BITCOIN_DATA.blockchainInfo['chain'])
        logger.add("bitcoin: blocks", SERVER.BITCOIN_DATA.blockchainInfo['blocks'])
        logger.add("bitcoin: peers", SERVER.BITCOIN_DATA.networkInfo['connections'])

        if SERVER.internetIsOn:
            logger.add("updating geolocation data... wait until complete (up to 2 minutes)")
            SERVER.updateGeolocationData(logger)   

    logger.add("server- starting network")
    SERVER.start_network()

    if SERVER.isOnline: 
        SERVER.start_all()
    else: 
        logger.add("server- socket not working")
        logger.add("server- stopping application and exit")



if __name__ == '__main__':
    main()